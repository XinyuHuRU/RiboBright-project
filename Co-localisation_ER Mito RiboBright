#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Oct 10 14:23:52 2025

@author: xinyuhu
"""

# 3D Manders Co-localization (full-stack thresholds, no Pearson)
# - One threshold per stack from full 3D histogram (Otsu)
# - Manders M1/M2 computed on full 3D volumes
# - OR (union) domain for Manders (standard)
# - Summary CSV + violin plots + stats


import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from tqdm import tqdm
import tifffile
from scipy.stats import mannwhitneyu, bootstrap, wilcoxon
from skimage.filters import threshold_otsu


# Cropping parameters 

CROP_X_START = 0
CROP_Y_START = 0
CROP_WIDTH = 2048
CROP_HEIGHT = 1024
CROP_X_END = CROP_X_START + CROP_WIDTH
CROP_Y_END = CROP_Y_START + CROP_HEIGHT


output_dir = "/Volumes/bifchem/Projects Hansen/Lab Members folders/XH/RiboBright/RB_XH_017/plots"
os.makedirs(output_dir, exist_ok=True)

experiment_roots = {
    "RB_XH_013": "/Volumes/bifchem/Projects Hansen/Lab Members folders/XH/RiboBright/RB_XH_013",
    "RB_XH_017": "/Volumes/bifchem/Projects Hansen/Lab Members folders/XH/RiboBright/RB_XH_017"
}


# Image loading

def load_image_stack(path):

    with tifffile.TiffFile(path) as tif:
        data = tif.asarray()
        if data.ndim == 4:
            if data.shape[0] in [2, 3]:            # (C, Z, Y, X)
                return data
            elif data.shape[1] in [2, 3]:          # (Z, C, Y, X) -> (C, Z, Y, X)
                return data.transpose(1, 0, 2, 3)
        raise ValueError(f"Unexpected data shape: {data.shape} in file: {path}")


# Thresholds & Manders (3D)

def fullstack_threshold(vol3d):
    """
    Single Otsu threshold from the full 3D histogram (flattened volume).
    """
    flat = vol3d.astype(float).ravel()
    if flat.size == 0:
        raise ValueError("Empty volume")
    return threshold_otsu(flat)

def compute_manders_3d(ch1_vol, ch2_vol, t1=None, t2=None):
    """
    Manders M1/M2 on the full 3D volume.
    Uses OR (union) domain, as standard for Manders co-occurrence.

    M1 = sum(ch1 where ch2 > t2) / sum(ch1 in domain)
    M2 = sum(ch2 where ch1 > t1) / sum(ch2 in domain)
    domain = (ch1 > t1) | (ch2 > t2)
    """
    ch1 = ch1_vol.astype(float)
    ch2 = ch2_vol.astype(float)

    if t1 is None: t1 = fullstack_threshold(ch1)
    if t2 is None: t2 = fullstack_threshold(ch2)

    mask1 = ch1 > t1
    mask2 = ch2 > t2
    domain = mask1 | mask2  # OR domain for Manders

    denom1 = ch1[domain].sum()
    denom2 = ch2[domain].sum()
    if denom1 == 0 or denom2 == 0:
        return np.nan, np.nan, t1, t2

    M1 = ch1[(mask2) & domain].sum() / denom1
    M2 = ch2[(mask1) & domain].sum() / denom2
    return M1, M2, t1, t2

# Analysis loop (per image â†’ 3D metrics)

def analyze_folder(experiment_path, experiment_label):
    results = []
    for group in ['RB_ER', 'RB_Mito']:
        group_path = os.path.join(experiment_path, group)
        for subdir, _, files in os.walk(group_path):
            for file in tqdm(files, desc=f"{experiment_label} - {group}"):
                if not file.endswith('.ome.tif') or file.startswith("._"):
                    continue
                filepath = os.path.join(subdir, file)
                try:
                    data = load_image_stack(filepath)  # (C, Z, Y, X)
                    num_channels, num_z = data.shape[:2]

                    # Channel assignment
                    if experiment_label == 'RB_XH_017':
                        if num_channels != 2:
                            raise ValueError(f"Expected 2 channels for RB_XH_017, got {num_channels}")
                        rb_ch, target_ch = 0, 1
                    else:
                        rb_ch = 0
                        target_ch = 1 if group == 'RB_ER' else 2

                    # Crop whole volume in YX (keep Z intact)
                    rb_vol = data[rb_ch, :, CROP_Y_START:CROP_Y_END, CROP_X_START:CROP_X_END]
                    tg_vol = data[target_ch, :, CROP_Y_START:CROP_Y_END, CROP_X_START:CROP_X_END]

                    # 3D Manders with full-stack thresholds
                    M1, M2, t1, t2 = compute_manders_3d(rb_vol, tg_vol)

                    # Optional quick look at one random slice (visual only)
                    if VISUALIZE_RANDOM_SLICES and num_z > 0:
                        z = np.random.randint(0, num_z)
                        fig, axs = plt.subplots(1, 2, figsize=(8, 4))
                        axs[0].imshow(rb_vol[z], cmap="Reds")
                        axs[0].set_title(f"RB (z={z}, Otsu={t1:.1f})")
                        axs[1].imshow(tg_vol[z], cmap="Greens")
                        axs[1].set_title(f"Target (z={z}, Otsu={t2:.1f})")
                        plt.suptitle(file)
                        plt.tight_layout()
                        plt.show()

                    results.append({
                        "Experiment": experiment_label,
                        "Group": group,
                        "Image": file,
                        "M1": M1,
                        "M2": M2,
                        "Otsu_t_RB": t1,
                        "Otsu_t_Target": t2
                    })

                except Exception as e:
                    print(f"Failed: {filepath}\nError: {e}")
    return results


# Run analysis

all_results = []
for label, path in experiment_roots.items():
    print(f"Analyzing {label}...")
    all_results.extend(analyze_folder(path, label))

df = pd.DataFrame(all_results)


# Save CSVs

summary_cols = ["Experiment", "Group", "Image", "M1", "M2"]
df_summary = df[summary_cols].copy()
summary_path = os.path.join(output_dir, "image_analysis_summary_Manders3D.csv")
df_summary.to_csv(summary_path, index=False)
print(f"Saved summary to: {summary_path}")

df.to_csv(os.path.join(output_dir, "manders3d_results_full.csv"), index=False)


# Stats helpers

def cohens_d(x, y):
    nx, ny = len(x), len(y)
    pooled_std = np.sqrt(((nx - 1) * np.var(x, ddof=1) + (ny - 1) * np.var(y, ddof=1)) / (nx + ny - 2))
    return (np.mean(x) - np.mean(y)) / pooled_std

def median_ci(data, confidence=0.95, n_resamples=10000):
    res = bootstrap((np.asarray(data),), np.median, confidence_level=confidence, n_resamples=n_resamples, method='basic')
    return res.confidence_interval.low, res.confidence_interval.high


# Plotting: ER vs Mito for M1 and M2

sns.set(style="white", font_scale=1.2)
palette = {"RB_XH_013": "#1f77b4", "RB_XH_017": "#ff7f0e"}

for metric in ["M1", "M2"]:
    plt.figure(figsize=(10, 6))
    ax = sns.violinplot(x="Group", y=metric, data=df, inner="box", palette="pastel", cut=0)
    sns.stripplot(x="Group", y=metric, data=df, hue="Experiment", palette=palette, dodge=True,
                  jitter=True, size=6, edgecolor="gray", linewidth=0.7)

    er_vals = df[df["Group"] == "RB_ER"][metric].dropna()
    mito_vals = df[df["Group"] == "RB_Mito"][metric].dropna()

    # Stats
    stat, pval = mannwhitneyu(er_vals, mito_vals, alternative='two-sided')
    effect_size = cohens_d(er_vals, mito_vals)

    median_er, median_mito = np.median(er_vals), np.median(mito_vals)
    mean_er, mean_mito = np.mean(er_vals), np.mean(mito_vals)

    ci_er, ci_mito = median_ci(er_vals), median_ci(mito_vals)

    fc_med = (median_er / median_mito) if median_mito != 0 else np.nan
    fc_mean = (mean_er / mean_mito) if mean_mito != 0 else np.nan

    print(f"\n{metric}: ER median = {median_er:.3f} (CI: {ci_er}), "
          f"Mito median = {median_mito:.3f} (CI: {ci_mito}), "
          f"Median FC = {fc_med:.2f}, Mean FC = {fc_mean:.2f}, "
          f"p (Mann-Whitney U) = {pval:.2e}, d = {effect_size:.2f}")

    max_y = max(df[metric].dropna()) + 0.05
    ax.plot([0, 1], [max_y, max_y], lw=1.5, color='black')
    ax.text(0.5, max_y + 0.01,
            f"Test: Mann-Whitney U\n"
            f"p = {pval:.2e}\n"
            f"FC (mean) = {fc_mean:.2f}\n"
            f"FC (median) = {fc_med:.2f}\n"
            f"d = {effect_size:.2f}",
            ha='center', fontsize=11)

    for i, (group, med, ci) in enumerate(zip(["RB_ER", "RB_Mito"], [median_er, median_mito], [ci_er, ci_mito])):
        ax.text(i, med + 0.01, f"Median: {med:.2f}\nCI: [{ci[0]:.2f}, {ci[1]:.2f}]",
                ha='center', va='bottom', fontsize=10)

    plt.title(f"{metric} Co-localization (3D; ER vs. Mito)")
    plt.ylabel(f"{metric} coefficient")
    plt.xlabel("Group")
    plt.legend(title="Experiment", loc="upper right")
    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, f"{metric.lower()}_violin_Manders3D.svg"), dpi=300)
    plt.show()


# Paired: M1 vs M2 within each group

for group in ["RB_ER", "RB_Mito"]:
    plt.figure(figsize=(6, 6))
    subset = df[df["Group"] == group][["M1", "M2"]].dropna()
    melted = pd.melt(subset.reset_index(drop=True), value_vars=["M1", "M2"],
                     var_name="Metric", value_name="Manders")
    ax = sns.violinplot(x="Metric", y="Manders", data=melted, inner="box", palette="pastel", cut=0)
    sns.stripplot(x="Metric", y="Manders", data=melted, jitter=True, size=6, color="gray", alpha=0.6)

    # Paired Wilcoxon (M1 vs M2 within group)
    if len(subset) >= 2:
        stat, pval = wilcoxon(subset["M1"], subset["M2"])
    else:
        pval = np.nan

    m1_med = np.median(subset["M1"]); m2_med = np.median(subset["M2"])
    m1_mean = np.mean(subset["M1"]);  m2_mean = np.mean(subset["M2"])

    fc_med = (m1_med / m2_med) if m2_med != 0 else np.nan
    fc_mean = (m1_mean / m2_mean) if m2_mean != 0 else np.nan

    max_y = melted["Manders"].max() + 0.05
    ax.plot([0, 1], [max_y, max_y], lw=1.5, color='black')
    ax.text(0.5, max_y + 0.01,
            f"Test: Wilcoxon signed-rank\n"
            f"p = {pval:.3e}\n"
            f"FC (mean) = {fc_mean:.2f}\n"
            f"FC (median) = {fc_med:.2f}\n"
            f"med M1 = {m1_med:.3f}\n"
            f"med M2 = {m2_med:.3f}",
            ha='center', fontsize=10)

    plt.title(f"{group}: M1 vs M2 (3D)")
    plt.ylabel("Manders Coefficient")
    plt.xlabel("")
    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, f"manders3d_{group}_M1_vs_M2_violin.svg"), dpi=300)
    plt.show()
