#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Jul 16 13:27:15 2025

@author: xinyuhu
"""
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import os
import glob
import re
from scipy.stats import ttest_ind
import numpy as np
import joypy



# Load and aggregate data
folder_paths = ['/Volumes/bifchem/Projects Hansen/Lab Members folders/XH/ManD results/XH_018/Data exported', '/Volumes/bifchem/Projects Hansen/Lab Members folders/XH/ManD results/XH_021/Data exported']

filename_pattern = r'export_(\d+)h_.*_Rep(\d+)_.*\.csv'
all_data = []

for folder in folder_paths:
    files = glob.glob(os.path.join(folder, '*.csv'))
    for file in files:
        fname = os.path.basename(file)
        match = re.match(filename_pattern, fname)
        if match:
            time = int(match.group(1))
            df = pd.read_csv(file)
            if 'GFP-A' not in df.columns:
                continue
            df = df[['GFP-A']].copy()
            df['Time'] = time
            all_data.append(df)

data = pd.concat(all_data, ignore_index=True)

# Normalize combined data to combined 0h mean
baseline_mean = data[data['Time'] == 0]['GFP-A'].mean()
data['GFP-A_normalized'] = data['GFP-A'] / baseline_mean

# Sort time for consistent plotting
data['Time'] = data['Time'].astype(int)
data['Time_str'] = data['Time'].astype(str) + 'h'

# === Ridgeline plot (optional, from before) ===
wide_df = data.pivot(columns='Time_str', values='GFP-A_normalized').dropna(axis=1, how='all')

plt.figure(figsize=(10, 6))
joypy.joyplot(wide_df, kind='kde', overlap=1, linewidth=1.5,
              colormap=plt.cm.viridis, fade=True, alpha=0.7, linecolor='black')
plt.title('Ridgeline Plot of Normalized GFP-A Distributions Over Time')
plt.xlabel('Normalized GFP-A')
plt.ylabel('Time Point')
plt.grid(False)
plt.tight_layout()
plt.savefig("/Volumes/bifchem/Projects Hansen/Lab Members folders/XH/ManD results/XH_021/Data exported/Ridgline plot_018 and 021.svg")
plt.show()

# === Calculate mean and SD per time ===
summary = data.groupby('Time')['GFP-A_normalized'].agg(['mean', 'std', 'count']).reset_index()

# === T-test of each time point vs 0h ===
pvals = []
baseline_data = data[data['Time'] == 0]['GFP-A_normalized']

for t in summary['Time']:
    if t == 0:
        pvals.append(np.nan)
        continue
    test_data = data[data['Time'] == t]['GFP-A_normalized']
    stat, p = ttest_ind(baseline_data, test_data, equal_var=False)
    pvals.append(p)

summary['p_value'] = pvals

# Optional: add significance stars

def format_pval(p):
    if p < 0.001:
        return "p < 0.001"
    else:
        return f"p = {p:.3f}"
   

#summary['significance'] = summary['p_value'].apply(sig_stars)

# === Simplified line plot reflecting ridgeline plot (Mean NANOG over time) ===
plt.figure(figsize=(8, 5))
sns.set(style='white')

# Use Time_str for x-axis labels
summary['Time_str'] = summary['Time'].astype(str) + 'h'

# Plot mean normalized GFP-A
plt.plot(summary['Time_str'], summary['mean'], marker='o', color='tab:blue', label='Mean normalized NANOG')

# Add shaded area for Â±1 standard deviation
plt.fill_between(summary['Time_str'],
                  summary['mean'] - summary['std'],
                  summary['mean'] + summary['std'],
                  color='tab:blue', alpha=0.3)

plt.title('Mean Normalized NANOG (GFP-A) Over Time')
plt.xlabel('Time')
plt.ylabel('Normalized NANOG (to 0h)')
plt.ylim(bottom=0.5)
plt.grid(True)
plt.tight_layout()
plt.savefig("/Volumes/bifchem/Projects Hansen/Lab Members folders/XH/ManD results/XH_021/Data exported/Mean_NANOG_lineplot.svg")
plt.show()


# === Plot line plot with shaded SD and exact p-values ===
plt.figure(figsize=(8, 5))
sns.set(style='white')

plt.plot(summary['Time'], summary['mean'], marker='o', color='tab:blue', label='Mean normalized GFP-A')
plt.fill_between(summary['Time'], summary['mean'] - summary['std'], summary['mean'] + summary['std'],
                 color='tab:blue', alpha=0.3)

# Add exact p-value text above each time point (skip 0h)
y_offset = summary['std'].max() * 1.5  # dynamic spacing
for idx, row in summary.iterrows():
    if row['Time'] == 0 or pd.isna(row['p_value']):
        continue
    plt.text(row['Time'], row['mean'] + y_offset,
             f"p = {row['p_value']:.2e}",  # scientific notation for clarity
             ha='center', fontsize=9, color='black')

print("\nSummary table with p-values:")
print(summary[['Time', 'mean', 'std', 'count', 'p_value']])

plt.title('Mean Normalized GFP-A Over Time with Exact p-values')
plt.xlabel('Time (hours)')
plt.ylabel('Normalized GFP-A (to 0h)')
plt.ylim(bottom=0.5)
plt.grid(False)
plt.legend()
plt.tight_layout()
plt.savefig("/Volumes/bifchem/Projects Hansen/Lab Members folders/XH/ManD results/XH_021/Data exported/line plot_018 and 021_with_pvalues.svg")
plt.show()

import os
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from pathlib import Path
from scipy.stats import ttest_rel
import numpy as np

# Parameters
EXPERIMENTS = [
    "/Volumes/VERBATIM SD/RB-XH010/Exported data/Exp1",
    "/Volumes/VERBATIM SD/RB-XH010/Exported data/Exp2"
]
POPULATIONS_TO_COMPARE = [("Q4", "Q1"), ("Q4", "Q2"), ("Q4", "Q3")]
OUTPUT_DIR = "/Volumes/VERBATIM SD/RB-XH010/Exported data/plots"
os.makedirs(OUTPUT_DIR, exist_ok=True)

# Color palette: Q4 always gray
PALETTE = {
    "Q1": "#1f77b4",
    "Q2": "#ff7f0e",
    "Q3": "#2ca02c",
    "Q4": "#a9a9a9"
}

# Set normalization method and optional x-axis limits
method = "zscore"  # or "minmax"
X_AXIS_LIMITS = (-6, 5)

def parse_file_metadata(filename, experiment_folder):
    parts = filename.split("_")
    if len(parts) < 6:
        raise ValueError(f"Filename format incorrect: {filename}")
    bio_rep = f"BioRep{parts[2]}"
    tech_rep = parts[3]
    pop_part = next((p for p in parts if p.startswith("Q")), None)
    if pop_part is None:
        raise ValueError(f"Population not found in filename: {filename}")
    pop = pop_part.split()[0]
    exp_id = Path(experiment_folder).name
    return exp_id, bio_rep, tech_rep, pop

def collect_data():
    all_data = []
    for exp in EXPERIMENTS:
        for file in os.listdir(exp):
            if not file.lower().endswith(".csv") or file.startswith("._"):
                continue
            filepath = os.path.join(exp, file)
            try:
                try:
                    df = pd.read_csv(filepath)
                except UnicodeDecodeError:
                    df = pd.read_csv(filepath, encoding="ISO-8859-1")
                exp_id, bio_rep, tech_rep, pop = parse_file_metadata(file, exp)
                df['Experiment'] = exp_id
                df['BiologicalReplicate'] = bio_rep
                df['TechnicalReplicate'] = tech_rep
                df['Population'] = pop
                all_data.append(
                    df[['BV421-A', 'Experiment', 'BiologicalReplicate', 'TechnicalReplicate', 'Population']]
                )
            except Exception as e:
                print(f"Skipping file {file} due to error: {e}")
    if not all_data:
        raise ValueError("No valid data files found. Please check your input folders and file format.")
    full_data = pd.concat(all_data, ignore_index=True)

    def normalize(group):
        if method == "zscore":
            mean = group["BV421-A"].mean()
            std = group["BV421-A"].std()
            group["BV421-A-Norm"] = (group["BV421-A"] - mean) / std
        elif method == "minmax":
            min_val = group["BV421-A"].min()
            max_val = group["BV421-A"].max()
            group["BV421-A-Norm"] = (group["BV421-A"] - min_val) / (max_val - min_val)
        return group

    normalized_data = full_data.groupby(
        ["Experiment", "BiologicalReplicate", "TechnicalReplicate"]
    ).apply(normalize).reset_index(drop=True)
    return normalized_data

def plot_aggregated_kde_and_bar(data, pop1, pop2):
    subset = data[data['Population'].isin([pop1, pop2])]

    # Aggregated KDE
    plt.figure(figsize=(8, 5))
    sns.kdeplot(
        data=subset,
        x="BV421-A-Norm",
        hue="Population",
        common_norm=False,
        fill=True,
        palette={pop1: PALETTE[pop1], pop2: PALETTE[pop2]},
        alpha=0.5
    )
    if X_AXIS_LIMITS:
        plt.xlim(X_AXIS_LIMITS)
    plt.title(f"KDE Plot: {pop1} vs {pop2}")
    plt.savefig(os.path.join(OUTPUT_DIR, f"KDE_{pop1}_vs_{pop2}.svg"))
    plt.show()

    # Calculate mean per technical replicate
    tech_rep_means = (
        subset.groupby(['BiologicalReplicate', 'TechnicalReplicate', 'Population'])['BV421-A-Norm']
        .mean()
        .reset_index()
    )

    # Summary stats: mean and SD across all technical replicates per population
    summary_stats = (
        tech_rep_means.groupby('Population')['BV421-A-Norm']
        .agg(['mean', 'std'])
        .reindex([pop1, pop2])
    )

    # Paired t-test on technical replicate means, pairing by BiologicalReplicate and TechnicalReplicate
    pivot = tech_rep_means.pivot_table(index=['BiologicalReplicate', 'TechnicalReplicate'], columns='Population', values='BV421-A-Norm')
    if pop1 in pivot.columns and pop2 in pivot.columns:
        # Drop rows with NaN in either column to keep pairs consistent
        paired_data = pivot.dropna(subset=[pop1, pop2])
        if not paired_data.empty:
            t_stat, p_val = ttest_rel(paired_data[pop1], paired_data[pop2])
        else:
            t_stat, p_val = np.nan, np.nan
    else:
        t_stat, p_val = np.nan, np.nan

    # Plot bar chart with SD error bars
    plt.figure(figsize=(6, 4))
    bars = plt.bar(
        x=summary_stats.index,
        height=summary_stats['mean'],
        yerr=summary_stats['std'],
        capsize=5,
        color=[PALETTE[p] for p in summary_stats.index]
    )

    # Overlay individual points (technical replicate means)
    for i, pop in enumerate(summary_stats.index):
        y = tech_rep_means[tech_rep_means['Population'] == pop]['BV421-A-Norm'].values
        x = np.random.normal(i, 0.08, size=len(y))  # jitter on x-axis for visibility
        plt.scatter(x, y, color='black', edgecolor='white', zorder=10)

    plt.ylabel("Mean Â± SD")
    plt.title(f"Mean BV421-A-Norm\n{pop1} vs {pop2} (p = {p_val:.2e})")
    plt.tight_layout()
    plt.savefig(os.path.join(OUTPUT_DIR, f"Bar_{pop1}_vs_{pop2}.svg"))
    plt.show()



def main():
    data = collect_data()
    for pop1, pop2 in POPULATIONS_TO_COMPARE:
        plot_aggregated_kde_and_bar(data, pop1, pop2)

if __name__ == "__main__":
    main()


